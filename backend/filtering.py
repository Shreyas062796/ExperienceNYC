import sys
import places
import json
from operator import itemgetter
from math import sin, cos, sqrt, atan2, radians

DEBUG = False


class Filtering:
	def __init__(self):
		self.bars = dict()
		self.restaurants = dict()

	def getBars(self):
		self.bars = places.getNYCBars()['results']

	def getRestaurants(self):
		self.restaurants= places.getNYCRestaurants()['results']

	# this is accomplished using the haversine formula (using the radius of earth in km)
	# assumes earth is a sphere, 0.5% error range
	def coorDistance(self, to_lat, to_lon, units='kms'):
		R = 6373.0 # approximate radius of earth

		lat1 = radians(self.latitude)
		lon1 = radians(self.longitude)
		lat2 = radian(to_lat)
		lon2 = radians(to_lon)

		dlat = lat2-lat1
		dlon = lon2-lon1

		a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
		c = 2* atan2(sqrt(a), sqrt(1-a))

		distance = R*c

		if units=='miles':
			#1km = 0.621371 miles
			distance = distance * 0.621371

		return distance

		# scoreing function for how likely you should be to go to a place
		# you shouldn't have to walk more than 3 miles from the place you are in
		def score(rating,distance):
			if distance>3:
				return 0
			else:
				return 1/(5.2-rating)*(3-distance)


		# WILL CHANGE AS WE CREATE A BETTER ESTIMATE
		# objective of this is to create a system that will work in the sort of give up .1 rating for ever 100 feet you have to walk
		# from the path you have
		def filterby(self, location_list, coordinates=(40.7831,-73.9712), rating=False, price_level=False, place_type=None):
			top_places = dict()
			for place in location_list:
				d_id = place['place_id']
				lng = place['geometry']['location']['lng']
				lat = place['geometry']['location']['lat']
				distance = coorDistance(lat, lng, units='miles')
				rating = float(place['rating'])

				place_score = score(rating, distance)
				top_places[d_id] = place_score
			return top_places
			# returns a dictionary with each popular as a key and their score as a value

		# return the list of places as a json for the frontend
		def asJson(self):
			pass	

		# get the top n elements of the dict generated by filterby top recomment the best
		def getTop(self, n):
			pass

		# my score functon is petty work on something better soon
		def newscore(self):
			pass



def main():
	if DEBUG:
		bars = places.getNYCBars()['results'] # bars is a list


		print(bars[1]['id'])
		sorted_by_score = sorted(bars, key=itemgetter('rating'))

		# with open('example.json', 'w') as File:
		# 	json.dump(bars, File)


if __name__ == '__main__':
	main()

